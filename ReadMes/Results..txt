Report made by Kent Phan
I will also be including a folder called "ResultsInfo" for this Assignment 2.10 holding most of my analysis information.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Points:
- I centered the test around testing platformer game based aspects ( Because that's what I'm making for the final)
- I spawned multiple objects in a scene to test the collision system.
- I Opted for a live game test instead of a unit test due to how integrated my collision system was into my game engine.I also
figured being able to see what was actually happening with GLIB would supply a good amount of information to me the engineer.
- I have not implemented layers into the collision system to seperate objects I have to check and objects I don't have to actually check.
I plan to do this later.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Premise:
Due to the difficulty of hooking up a collision unit test for a collision system
that is so deeply integrated into my engine. I opted to set up my game in a state that would push the collision system to it's limits
in a state that could stress test collisions.

I created about 32 game objects before I started running into frame rate drops. Which arguably is not a lot. :(
(20 static objects, 12 movable objects).
The 20 static objects act as platforms, while the 12 movable objects have gravity that constantly accelerates them towards the
static platformers. I refrained from user input to get as much raw collision data as possible.

Due to how I set up my Collision and Physics Frame. Objects can accelerate a bit into the other object if the framerate gets bad enough. Will resolve at a later time.
Doing Both x86 and 64 bit test

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Beginning:
In the Screenshot ResultsPre<Build>_Summary.png you can find the performance of my game in the beginning.
From it you can see that I had to performance indicators in function GetCofactor and GetDeterminant. Which are used a lot to
calculate the inverse of a matrix.

In the Screenshot ResultsPre<Build>_Functions.png you can see the function breakdown.

Take note that alot of my Vector code is inlined. So it's performance is scattered across the code. 
In optimizing my Vectors hopefully overall performance will increase.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Things I Optmized:
- All Vector Functions
- Matrix Inverse
- Matrix Multiply
- Tracking of static objects leads to skipping of Physics calculations.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

After Optimization:
- I had to implement a whole bunch of fixes. So I redid one of my initial performance profile. I found that the results did not differ to much from my initial run. So I stuck to using the initial run.
- Results can be observed in ResultsPost<Build>_Summary.png and ResultsPost<Build>_Functions.png. I also supplied comparison reports of before and after.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Analysis:
With the implementation and rework into SIMD. I got key performance benefits that I observed. (For one I could double the number of objects in my game and not get as hard of a performance hit)
Looking at the comparison screen shots I took. You can see that the Inclusive Sample Rate % of the High Level Collision function decreased by at least 40%. Meaning my program was spending less
time in the Collision Step.
Comparing summary reports. It seems the sample rate spread out more after optimization. Which I interpret as being good because my program isn't spending too much time in one place.

Overall I believe the SIMD optimizations I made were beneficial to my program.

